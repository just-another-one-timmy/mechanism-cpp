#ifndef GROUPMANAGER_H_INCLUDED
#define GROUPMANAGER_H_INCLUDED

#include <list>
#include <map>
#include <set>
#include <vector>
#include <algorithm>
using namespace std;

#include "CompManager.h"
class CompManager;

#include "GroupBuilder.h"

#include "Group.h"
/**
@warning Нет полной документации для этого класса! Дописать!
@todo Дописать документацию!
@brief Класс для управления группами.
@details После того, как части механизма созданы с помощью CompManager, надо использовать GroupManager для анализа групп.
Данный класс позволяет:
<ul>
<li> Добавлять группы "вручную", указывая, из каких звеньев и КП они состоят
<li> Просчитывать параметры механизма для данного состояния первой группы
<li> Задавать такие параметры механизма, как ограничения, которым подчиняется 1-ая группа и стиль ее движения (об этом ниже)
<li> Изменять состояние первой группы (делать шаг), с учетом параметров механизма
<li> Задавать стиль движения первой группы. Обобщенная координата первой группы сначала меняетс от minGC до maxGC. Потом если установлен флаг jump,
     координата меняется сразу на minGC и процесс повторяется. Если же jump=false, то сначала координата уменьшается от maxGC до minGC и процесс повторяется.
<li> Разбивать механизм на группы в автоматическом режиме
<li> Получать список групп механизма
</ul>

Для использования данного класса, надо создать его экземпляр, связав его с экземляром класса CompManager (см. конструктор).
Далее, необходимо установить параметры, вызывая методы SetJump, SetMaxGC, SetMinGC.
После этого надо добавить первую группу, т.е. ту, с которой будут начинаться анализ и расчеты: AddFirstGroupByName.
*/
class GroupManager
{
    private:
        double step_size, mingc, maxgc;
        bool jump;
        bool move_forward; // вращаем по или против часовой? Толкаем вперед или назад?
        CompManager *cm;

        set <Segment *> black_vertexes;

        set <KPair *> black_edges;

        set <KPair *> common_edges(Segment *s1, Segment *s2);

        map <Segment *, set <KPair *> > edges; // для каждого ребра хранит список ребер

        void AddSecondGroup(KPair *k1, KPair *k2, KPair *k3, Segment *s1, Segment *s2);

        void AddBlackEdge(KPair *K);
        void AddBlackVertex(Segment *s);
        void FindPath(vector <Segment *> path, int len);
        void ProcessPath(vector <Segment *> path);
    public:
        /**
        @brief Строит списки вершин для каждого ребра графа
        @details Ребрами графа являются КП, а вершинами - звенья. Еще раз: ребрами графа являются КП, а вершинами - звенья.
                 Внутренний АМ edges по указателю на звено позволит получать список КП, связанных с этим звеном.
        */
        void BuildEdgesSets();

        /**
        @brief Производит расчет механизма
        @details Проходит по всем элементам списка groups, вызывает метод TF0. Потом тоже самое, но вызывает TF1. Потом TF2.
        @bug Имя метода не соответсвтует действиям.
        */
        void CalcNextStep();

        /**
        @brief Делает шаг для первой группы (т.е. вычисляет ее следующее положение)
        @details Изменяет обобщенную координату первой группы. Она меняется на step_size в зависимости от того, в каком
                 направлении сейчас движется механизм и ограничений mingc, maxgc.
                 Если координата становится больше допустимой ( > maxgc), то
                 <ul>
                 <li> Если jump==true, то координата приравнивается к mingc
                 <li> Если jump==false, то меняется направление движения (move_forward=false).
                      Теперь координата будет медленно убывать до mingc.
                 </ul>
                 Если координата становится меньше допстимой ( < mingc), то изменяется направление движения (move_forward=true).
        */
        void MakeStep();

        /**
        @brief Устанавливает величину шага
        @details Заносит величину шага в step_size. Отрицательную величину умножает на -1.
        @param s Величина шага, которую надо установить.
        */
        void SetStepSize(double s);

        /**
        @brief Возвращает текущую величину шага
        @return Величина шага
        */
        double GetStepSize();

        /**
        @brief Добавляет первую группу
        @details <ol>
                 <li> Создает новую группу 1-го класса, называет ее "("+S1->name+","+S2->name+")".
                 <li> Добавляет группу в список групп механизма (важно, чтобы первой была добавлена группа, с которой надо начинать расчет!)
                 <li> Отмечает данные звенья и КП как "черные" (см. Analyze)
                 </ol>
        @param KPName, SegmentName1, SegmentName2 Имена соответственно КП, первого звена и второго звеньев группы
        */
        void AddFirstGroupByName(string KPName, string SegmentName1, string SegmentName2);

        /**
        @brief Добавляет вторую группу
        @details <ol>
                 <li> Создает новую группу 2-го класса, называет ее "("+S1->name+","+S2->name+")".
                 <li> Добавляет группу в список групп механизма
                 </ol>
        @param KP1Name, KP2Name, KP3Name, SegmentName1, SegmentName2 Имена соответственно первой, второй и третьй КП, а также первого и второго звеньев группы
        @param mj1, mj2 Признаки сборки группы
        @bug Нет проверок существования КП и сегментов с нужными именами
        */
        void AddSecondGroupByName(string KP1Name, string KP2Name, string KP3Name, string SegmentName1, string SegmentName2, signed char mj1=1, signed char mj2=1);

        /**
        @brief Делает звено "землей"
        @details Ищет звено с нужным именем и отмечает его как "земля", добавляя во внутренний список "черных вершин"
        @param GroundName Имя звена, которое нужно отметить землёй
        */
        void AddGround(string GroundName);

        /**
        @todo Написать подробное объяснение
        */
        void Analyze();

        /**
        @brief Устанавливает максимально допустимое значение обобщенной координаты
        @param x Устанавливаемое значение
        @bug Никаких проверок
        */
        void SetMaxGC(double x);

        /**
        @brief Устанавливает минимально допустимое значение обобщенной координаты
        @param x Устанавливаемое значение
        @bug Никаких проверок
        */
        void SetMinGC(double x);

        /**
        @brief Возвращаает максимальное значение обобщенной координаты
        @return Максимально допустимое значение обобщенной координаты
        */
        double GetMaxGC();

        /**
        @brief Возвращаает минимально значение обобщенной координаты
        @return Минимально допустимое значение обобщенной координаты
        */
        double GetMinGC();

        /**
        @brief Устанавливает режим "прыжка"
        @details При движении механизма, обобщенная координата 1-ой группы может превысить свое максимально допустимое значение.
                 Тогда если режим прыжка установлен в true, то обобщенная координата сразу приравнивается к своему минимально допустимму значению.
                 Иначе (режим прыжка в false) обобщенная координата остается равной своему макс. допустимому значению, но меняется направление ее изменения.
                 Т.е. теперь GC начинает уменьшаться до минимально допустимого значения и тогда направление опять меняется.
        */
        void SetJump(bool x);

        /**
        @brief Возвращает, установлен ли режим прыжка
        @return true, если установлен режим прыжка,
                false, если не установлен
        */
        bool GetJump();

        /**
        @brief Конструктор, производится начальная инициализация
        @details <ol>
                 <li> Устанавливается внутренний указатель на CompManager
                 <li> Мин. и макс. допустимые значения GC приравниваются к 0
                 <li> Устанавливается режим движения вперед (GC имзеняется в сторону увеличения)
                 <li> Устанавливается режим прыжка в true
                 </ol>
        @bug Не проверяется, доступен ли CompManager. А вдруг переданный указатель - NULL?
        */
        GroupManager(CompManager *cm);

        /**
        @brief Список групп
        @details Список групп механизма. Пути, приводящие к добавлению элемента в этот список:
                 <ul>
                 <li> Вызов метода Analyze(), который нашел еще группы в механизме
                 <li> Вызов методов AddFirstGroup(), AddSecondGroup()
                 <li> Добавление какого-нибудь мусора путем обращения в списку извне! Плохо! <b>Очень плохо!</b>
                 </ul>
        @bug Архитектурная ошибка, нельзя оставлять этот список в public
        */
        list <Group *> groups;
};

#endif // GROUPMANAGER_H_INCLUDED
